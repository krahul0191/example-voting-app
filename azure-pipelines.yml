# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy scan, and more:
# https://aka.ms/yaml
trigger:
- none

# defined parameters to select environments
parameters:
  - name: environment
    displayName: Environment
    default: dev
    type: string
    values:
      - dev
      - test
      - stage
      - prod

  - name: repo_url
    displayName: Azure Container Repositry URl 
    default: axrdemo.azurecr.io

  - name: azure_storage
    displayName: Azure Storage Account Name
    default: azurestorage

  - name: azure_storage_container
    displayName: Azure Storage Container
    default: terraform

  - name: infra
    displayName: Infra Provision
    type: boolean
    default: true

  - name: build
    displayName: Build App
    type: boolean
    default: true

  - name: deploy
    displayName: Deploy App
    type: boolean
    default: true


# Defined variables aks_serviceconnection, acr_serviceconnection, repo_url are must to update for new configuration
variables:
  imageName_vote: vote
  imageName_result: result
  imageName_worker: worker
  aks_serviceconnection: 'example_aks'
  acr_serviceconnection: 'acr'
  namespaces: 'vote'
  password: 'postgres'
  secretName: 'acrsecret'
  secretNameDb: 'dbsecret'
  tags: 'latest'

# Stage to build/compile the code
stages:

- ${{ if eq(parameters.infra, true) }}:
  - stage: Build
    displayName: Build App
    jobs:
      - job: Compile
        displayName: 'Build Apps'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
        - task: TerraformInstaller@0
          inputs:
            terraformVersion: 'latest'

        - task: TerraformTaskV2@2
          inputs:
           provider: 'azurerm'
           command: 'init'
           workingDirectory: 'Infra_provision'
           backendAzureRmStorageAccountName: '${{ parameters.azure_storage }}'
           backendAzureRmContainerName: '${{ parameters.azure_storage_container }}'
           backendAzureRmKey: 'tfstate'
          displayName: 'Terraform Backend' 

        - task: TerraformTaskV2@2
          inputs:
           provider: 'azurerm'
           command: 'apply'
           workingDirectory: 'Infra_provision'
           commandOptions: '-auto-approve'
          displayName: 'Infra Provisining' 

- ${{ if eq(parameters.build, true) }}:
  - stage: Build
    displayName: Build App
    jobs:
      - job: Compile
        displayName: 'Build Apps'
        pool:
          vmImage: 'ubuntu-latest'
        steps:

        # Building the vote docker image and pushing it to ACR  
        - task: Docker@2
          displayName: 'building vote image'
          inputs:
            containerRegistry: '$(acr_serviceconnection)'
            repository: '$(imageName_vote)'
            command: 'buildAndPush'
            Dockerfile: '$(Build.SourcesDirectory)/vote/Dockerfile'
            tags: |
              $(tags)

       # Building the result docker image and pushing it to ACR  
        - task: Docker@2
          displayName: 'building result image'
          inputs:
            containerRegistry: '$(acr_serviceconnection)'
            repository: '$(imageName_result)'
            command: 'buildAndPush'
            Dockerfile: '$(Build.SourcesDirectory)/result/Dockerfile'
            tags: |
              $(tags)

        # Building the worker docker image and pushing it to ACR 
        - task: Docker@2
          displayName: 'building worker image'
          inputs:
            containerRegistry: '$(acr_serviceconnection)'
            repository: '$(imageName_worker)'
            command: 'buildAndPush'
            Dockerfile: '$(Build.SourcesDirectory)/worker/Dockerfile'
            tags: |
              $(tags)

        # publish kubernetes yaml files for deployment
        - task: PublishPipelineArtifact@1
          inputs:
            targetPath: '$(Pipeline.Workspace)/s/azure_kubernetes'
            artifact: 'manifests'
            publishLocation: 'pipeline'

#stage to deploy the kubernetes objects on cluster
- ${{ if eq(parameters.deploy, true) }}:
  - stage: Deploy
    displayName: Deploy App
    jobs:
    - job: deploy
      displayName:  deploy-${{parameters.environment}}
      pool:
       vmImage: 'ubuntu-latest'
      steps:
           - task: DownloadPipelineArtifact@2
             inputs:
               buildType: 'current'
               artifactName: 'manifests'
               targetPath: '$(Pipeline.Workspace)/manifests'

           # creating secret to authnticate with Azure contianer registery
           - task: KubernetesManifest@0
             displayName: 'Create Secrets ACR'
             inputs:
               action: 'createSecret'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               secretType: 'dockerRegistry'
               secretName: '$(secretName)'
               dockerRegistryEndpoint: '$(acr_serviceconnection)'


            # creating secret to create database username and password encrypted
           - task: KubernetesManifest@0
             displayName: 'create secret DB'
             inputs:
               action: 'createSecret'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               secretType: 'generic'
               secretName: '$(secretNameDb)'
               secretArguments: '--from-literal=username=postgres --from-literal=password="$(password)"'  # password's value defined in azure pipline varibales


           #Replacing secret name in db-deployment.yml file
           - task: replacetokens@5
             inputs:
               rootDirectory: '$(Pipeline.Workspace)/manifests'
               targetFiles: 'db-deployment.yaml'
               encoding: 'auto'
               tokenPattern: 'custom'
               tokenPrefix: '#{'
               tokenSuffix: '}#'
               writeBOM: true
               actionOnMissing: 'warn'
               keepToken: false
               actionOnNoFiles: 'continue'
               enableTransforms: false
               useLegacyPattern: false
               enableTelemetry: true

         # Fetching image from ACR for vote apps and deploying it on AKS
           - task: KubernetesManifest@0
             displayName: 'Deploy vote App Kubernetes'
             inputs:
               action: 'deploy'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               manifests: |
                 $(Pipeline.Workspace)/manifests/vote-deployment.yaml
                 $(Pipeline.Workspace)/manifests/vote-service.yaml
               containers: '${{parameters.repo_url}}/$(imageName_vote):$(tags)'
               imagePullSecrets: '$(secretName)'
   
          # deploying image for Redis application on AKS
           - task: KubernetesManifest@0
             displayName: 'Deploy Redis Kubernetes'
             inputs:
               action: 'deploy'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               manifests: |
                 $(Pipeline.Workspace)/manifests/redis-deployment.yaml
                 $(Pipeline.Workspace)/manifests/redis-service.yaml

          # deploying image for Postgres database on AKS
           - task: KubernetesManifest@0
             displayName: 'Deploy DB Kubernetes'
             inputs:
               action: 'deploy'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               manifests: |
                 $(Pipeline.Workspace)/manifests/db-deployment.yaml
                 $(Pipeline.Workspace)/manifests/db-service.yaml

           # Fetching image from ACR for worker apps and deploying it on AKS
           - task: KubernetesManifest@0
             displayName: 'Deploy worker Kubernetes'
             inputs:
               action: 'deploy'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               manifests: |
                 $(Pipeline.Workspace)/manifests/worker-deployment.yaml
                 $(Pipeline.Workspace)/manifests/autoscale-worker-deployment.yaml
                 $(Pipeline.Workspace)/manifests/worker-service.yaml
               containers: '${{parameters.repo_url}}/$(imageName_worker):$(tags)'
               imagePullSecrets: '$(secretName)'

           # Fetching image from ACR for result apps and deploying it on AKS
           - task: KubernetesManifest@0
             displayName: 'Deploy result app Kubernetes'
             inputs:
               action: 'deploy'
               kubernetesServiceConnection: '$(aks_serviceconnection)'
               namespace: '$(namespaces)'
               manifests: |
                 $(Pipeline.Workspace)/manifests/result-deployment.yaml
                 $(Pipeline.Workspace)/manifests/result-service.yaml
               containers: '${{parameters.repo_url}}/$(imageName_result):$(tags)'
               imagePullSecrets: '$(secretName)'
